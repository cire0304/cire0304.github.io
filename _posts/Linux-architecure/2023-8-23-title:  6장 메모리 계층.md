---
title:  "6장 메모리 계층"

categories:
  - Linux-architecture
tags:
  - Linux

toc: true
toc_sticky: true

date: 2023-08-23
last_modified_at: 2023-08-23
---

실습과 그림으로 배우는 리눅스 구조 6장의 내용을 정리한 글입니다.
{: .text-center .notice--primary}

컴퓨터에는 다양한 메모리 장치들이 있습니다. 아래의 그림에서 위로 올라갈수록 메모리의 크기는 작아지고 단위 바이트당 가격은 비싸지지만 읽거나 쓰는 속도는 빨라집니다.

![](https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Ff9c8088c-0fec-4dad-ac95-ddf3601aa1d4%2F%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0.png)

## 캐시 메모리

### 케시 메모리가 필요한 이유

컴퓨터의 동작 흐름은 기본적으로 다음과 같습니다.

1. 명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽습니다.
2. 레지스터에 있는 데이터를 바탕으로 계산합니다.
3. 계산 결과를 메모리에 씁니다.

레지스터에서 계산하는 평균 시간보다 메모리에 접근하는 데 걸리는 시간, 즉 레이턴시가 극도로 느립니다.  
그렇기 때문에, 컴퓨터의 처리 속도는 메모리에 읽고 쓰는 레이턴시에 크게 좌우 됩니다.

캐시 메모리는 레지스터에 안에서 계산하는 것과 메모리에 접근한 것, 양쪽의 처리 시간의 차이를 메우는 데 필요합니다.  
CPU는 캐시 메모리에 있는 데이터에만 접근할 때에는 모든 접근이 캐시 메모리의 속도로 처리되므로, 캐시 메모리가 없는 경우보다 훨씬 빠르게 처리됩니다.

> 캐시의 더티(dirty)

쓰기 연산을 할 때, 메모리에 바로 저장되는 것이아니라 `먼저 캐시에 저장`하게됩니다. 이때 메모리로부터 읽어 들인, 캐시 속 데이터가 변경되었음 나타내는 플래그(더티)를 표시합니다.  
추후 백그라운드 처리로 메모리에 다시 기록되고, 캐시 값은 더이상 더티가 아니게 됩니다.

### 캐시 메모리가 가득 찬 경우

캐시 메모리가 가득 찬 경우, 캐시 메모리에 존재하지 않는 데이터를 추가로 읽으면 기존의 캐시 메모리중 1개를 파기합니다.  
파기하는 캐시가 더티라면 대응되는 메모리에 덮어쓴 다음 파기하는 동기화 작업이 일어납니다.  
캐시 메모리가 가득 차고 모든 캐시 라인이 더티라면 메모리 접근을 할 때마다 캐시 라인 안의 데이터가 자주 바뀌게 되는 `스래싱`이 발생하여 성능이 크게 감소할 수 있습니다.

### 계층형 캐시 메모리

CPU는 캐시 메모리가 계층형 구조로 되어 있습니다. 각 계층은 사이즈, 레이턴시, 어느 논리 CPU 사이에 공하는가 등이 다릅니다.  
계층형 구조를 구성하는 각 캐시 메모리는 `L1`, `L2`, `L3` 등의 이름이 붙고, 번호가 높아질수록 레지스터로부터 멀어지며 용량이 커지고 속도가 느려집니다.

### 메모리 참조의 국소성

시스템은 메모리에 있는 데이터가 아니라 캐시에 있는 데이터에 접근할 확률이 높습니다. 그 이유는 메모리 참조의 국소성 같은 특성이 있기 때문입니다. 프로세스는 짧은 시간을 놓고 생각해보면, 자신이 획득한 메모리의 총량보다 훨씬 좁은 범위의 메모리에 접근하는 성향을 가집니다.

> 시간 국소성

특정 시점에서 접근하는 데이터는 가까운 미래에 다시 접근할 가능성이 큽니다. 전형적인 예로는 루프 처리 중인 코드 영역을 들 수 있습니다.

> 공간 국소성

특정 시점에 어떤 데이터에 접근하면 그 데이터와 가까운 주소에 있는 데이터를 접근할 확률이 높습니다. 전형적인 예로는 배열의 전첵 검색등을 들 수 있습니다.

## Translation Lookaside Buffer

프로세스는 다음과 같은 순서에 따라 가상의 주소의 데이터에 접근합니다.

1. `물리 메모리상에 존재`하는 페이지 테이블을 참고하여 가상 주소를 물리 주소로 변환합니다.
2. 1에서 구한 물리 메모리에 접근합니다.

위의 1번 과정에서는 캐시가 아닌 메모리 접근이 발생합니다. 따라서 페이지 테이블을 저장하기 위한 캐시 `Translation Lookaside Buffer`라는 캐시를 사용하여, 페이지 테이블을 빠르게 참고할 수 있습니다.

## 페이지 캐시

CPU로부터 메모리에 접근하는 속도와 비교해서 저장 장치에 접근하는 속도는 매우 느립니다.  
이 속도 차이를 줄이기 위해, `저장 장치 내의 파일 데이터`를 `메모리`에 캐싱을 할 수 있습니다.  
이는 캐시 메모리와 매우 비슷합니다.

캐시 메모리는 캐시라인 단위로 데이터를 다루지만 페이지 캐시는 페이지 단위로 데이터를 다룹니다.  
{: .notice--info}

프로세스가 파일을 읽을 때, 프로세스의 메모리에 데이터를 직접 복사하는 것이 아닌, 커널의 메모리 내에 있는 페이지 캐시라는 영역에 복사한 뒤 이 데이터를 프로세스 메모리에 복사합니다. (캐시 메모리와 마찬가지로 페이지 더티가 존재합니다.)
{: .notice--info}


