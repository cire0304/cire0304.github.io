---
title:  "제너릭에 대해서 공부해보자!"

categories:
  - Java
tags:
  - [Java, Collection]

toc: true
toc_sticky: true

date: 2023-08-22
last_modified_at: 2023-08-22
---

# 제너릭

- 컴파일 시점에 컴파일러가 타입을 체크를 하는 것
  - 컴파일러가 문법 오류를 잡아주기 때문에, 좀 더 타입 안전한 프로그래밍이 가능하다.

## Type parameter와 Type argument

```java
public class Generics {
  class Hello<T> { // T -> type parameter
  }

  public static main(String[] args) {
    new Hello<String>(); // String -> type argument
  }
}
```

## Raw Type

type argument를 사용하지 않은 타입을 말한다.

```java
public void someMethod() {
  List<Integer> ints = Arrays.asList(1, 2, 3); // type argument를 사용한 List

  List rawType = ints; // type argument를 사용하지 않는 List
}
```

Raw Type은 `컴파일이 타입 체크`를 해줄 수 없기 때문에, 컴파일 에러가 아닌 런타임 에러가 발생할 수 있다.

따라서, Raw Type의 사용은 지양해야 한다.

> 자바에서 Raw Type을 지원하는 이유
> 
> Java5 이전과의 호환성 때문이다. 제너릭은 Java5 부터 주가된 기능으로, 그 이전의 코드는 제너릭이라는 것이 없었다. 최신 버전의 Java에서 예전 자바의 코드 또한 실행되어야 하기 때문에, Raw Type을 지원한다.

## 제너릭 메서드

메서드 레벨에서 Type parameter를 적는 것

제너릭 메서드가 필요한 이유는 다음과 같다.
- 제너릭 클래스에 있는 type parameter가 아닌 메서드 에서 사용하고 싶은 type parameter가 있는 경우
- static 메서드에서 제너릭을 사용하기 위해
  - static 메서드는 인스턴스를 만들기 전에 사용이 가능하기 때문에, static 메서드 사용 시점에 type을 결정해야 한다.

## Bounded Type parameter

Type parameter는 어떠한 타입이 들어갈 수 있다.  
이러한 Type parameter에 제한된 타입만 들어갈 수 있도록 하는 것이 Bounded Type parameter이다.

이렇게 Type parameter에 제한을 두는 이유는 다음과 같다.
- 특정 인터페이스나 클래스를 구현 또는 상속한 클래스만 받고 싶을 경우
  - Ex) 비교 연산을 위해, Comparalbe 인터페이스를 구현한 클래스만 인자로 받고 싶을 경우

## 제너릭 vs 와일드 카드

제너릭 : type parameter에서 제공하는 기능이 필요할 때 사용
와일드 카드 : type parameter에서 제공하는 기능이 필요하지 않을 때 사용

```java
List<?> list; 
// 1. 원소를 꺼내 와서는 Object에 정의되어 있는 기능만 사용하겠다. equals(), toString(), hashCode()…
// 2. List에 타입이 뭐가 오든 상관 없다. 나는 List 인터페이스에 정의되어 있는 기능만 사용하겠다. size(), clear().. 단, 타입 파라미터와 결부된 기능은 사용하지 않겠다! add(), addAll()

List<T> list;
// 1. 원소를 꺼내 와서는 Object에 정의되어 있는 기능만 사용하겠다. equals(), toString(), hashCode()…
// 2. List에 타입이 뭐가 오든 상관 없다. 나는 List 인터페이스에 정의되어 있는 기능만 사용을 하고, 타입 파라미터와 결부된 기능도 사용하겠다.
```

## 제너릭의 상속에서 주의할 점

`Number`은 `Integer`의 super 클래스가 맞다.
하지만 `List<Number>`은 `List<Integer>`의 super 클래스가 아니다.

제너릭은 클래스간 상속에 영향을 주지 않는다.

## capture (공부 필요)


> 출처  
> [토비의 봄 (제너릭)](https://www.youtube.com/watch?v=ipT2XG1SHtQ&list=PLv-xDnFD-nnmof-yoZQN8Fs2kVljIuFyC&index=12&ab_channel=%ED%86%A0%EB%B9%84%EC%9D%98%EC%8A%A4%ED%94%84%EB%A7%81)
> https://vvshinevv.tistory.com/54



# String Constant Poll vs Constant Pool

String Constant Poll과 Constant Poll은 이름이 비슷하다.
하지만 위의 두 용어는 완전히 다른 용어이다.

저장되는 위치, 저장하는 데이터의 종류, 관리 주체까지 모든 것이 다른 저장공간이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeaJffC%2FbtsgwMqYWOP%2FlWjjsBoXdDoUMWgrSr5ZCK%2Fimg.png)


|| String Constant Pool | Constant Pool inside a Java class file |	Runtime Constant pool |
|:-:|:-:|:-:|:-:|
|역할|	String 객체의 상수 값을 저장(캐싱)|클래스 파일의 상수 값을 저장|Class Constant pool에서 읽어온 상수 값, 클래스 메타데이터 저장|
|저장되는 값 | String 상수 값 <br> ex) "Hello", "World" | 클래스 파일에 포함된 상수 값 <br> ex) 123, 3.14, true | 클래스 파일에 포함된 상수 값. Class Constant pool에 저장되어있던 값이 런타임시 이 영역으로 저장된다. |
| 저장 위치 | Java 7 이전 - Perm <br> Java 8 이상 - Metaspace| Class file | 		Java 7 이전 - Perm <br> Java 8 이상 - Metaspace |
|저장 트리거| String.intern(), String을 리터럴로 생성 | 컴파일시 생성됨 | 클래스파일에 코드 레벨로 선언된 상수풀이 런타임시 로더의 판단에 의해 올라옴. |
|불변 여부|불변 여부	불변 (Immutable)|Class 파일 자체는 불변.|Runtime시 동적 로드에 의해 변경될 수 있음	불변이 아님.클래스파일이 동적으로 로딩되고 초기화되기 때문에, 로드될 때 마다 변경됨|

## String Constant Pool은 GC의 대상이 될까?

GC의 대상은 Heap 영역이라고 배웠다. 그리고 String Constant Pool이 저장되는 곳은 Metaspace(Java8 이상) 이라고 한다.

그렇다면 String Constant Pool에 저장되 있는 데이터는 GC의 대상이 되지 않는 걸까?

정답은 그렇다. String Constant Pool에 저장되어 있는 String literals은 GC의 대상이 되지 않는다.

다만 여기서 확실히 알아야 할 점은, 모든 String 객체가 String Constant Pool에 저장되는 것이 아니라는 점이다.
-> 동적으로 생성된 String 객체는 Heap 영역에 저장된다.


> 출처  
> https://deveric.tistory.com/123
> https://stackoverflow.com/questions/18406703/when-will-a-string-be-garbage-collected-in-java
