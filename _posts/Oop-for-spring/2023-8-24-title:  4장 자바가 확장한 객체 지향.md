---
title:  "4장 자바가 확장한 객체 지향"

categories:
  - Oop-for-spring
tags:
  - [Java, Spring, OOP]

toc: true
toc_sticky: true

date: 2023-08-24
last_modified_at: 2023-08-24
---

스프링 입문을 위한 자바 객체 지향의 원리와 이해 4장의 내용을 정리한 글입니다.
{: .text-center .notice--primary}

## abstract 키워드 - 추상 메서드와 추상 클래스

추상 메서드를 간단하게 설명하면 *선언부는 있는데 구현부가 없는 메서드*를 말합니다. 추상 메서드는 *서브 클래스에게 메서드의 구현을 강제*합니다. 또한, 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 합니다.

```java
public abstract class Animal {
  abstract void act(); // 추상 메서드이기 때문에 구현부를 작성할 수 없음
}
```

추상 클래스는 인스턴스, 즉 객체를 만들 수 없는 클래스 입니다. 추상 클래스는 *슈퍼 클래스의 특성을 서브 클래스가 확장*하여야지만 사용할 수 있도록 하기위해 존재합니다.

## 생성자

생성자도 메서드입니다. 반환값이 없고, 클래스명과 같은 이름을 가진 메서드를 *객체를 생성하는 메서드*라고 해서 `객체 생성자 메서드`라고도 합니다.  

개발자가 생성자를 구현하지 않으면 자바 컴파일러가 기본 생성자를 만들어 줍니다. 하지만 인자가 있는 생성자를 하나라도 만든다면 자바는 컴파일러는 기본 생성자를 만들어 주지 않습니다.
{: .notice--info}

## 클래스 생성 시의 실행 블록, static 블록

객체 생성자가 있다면 `클래스 생성자`도 있을지 생각해 볼 수 있습니다. 하지만 클래스 생성자는 존재하지 않습니다. 하지만, 클래스가 `loading`될 때 스태틱 영역에 배치될 때 실행되는 `static 블록`이 있습니다. `static 블록`을 통해 static(클래스) 맴버 변수를 초기활 할 수 있습니다.

```java
public class Animal {
  static {
    // static 맴버 초기화 코드
  }
}
```

static 블록에서 사용할 수 있는 속성과 메서드는 static 맴버 뿐입니다. 객체 맴버 변수는 클래스 loading 시점에 초기화가 불가능하기 때문입니다.  
{: .notice--info}

> 클래스의 loading 시점

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때


## final 키워드

final은 마지막, 최종이라는 의미를 가진 단어입니다. final 키워드가 나타날 수 있는 곳은 `클래스`, `변수`, `메서드` 입니다.

### final과 클래스

클래스에 final이 붙으면 어떻게 될까요? 상속이 불가능해집니다.

```java
public final class Cat{}

public class StreetCat extends Cat {} // Cat은 final class이기 때문에 컴파일 오류 발생!
```

### final과 변수

변수에 final이 붙었다면 변경 불가능한 상수가 됩니다. final static 변수는 선언시에, 또는 정적 생성자에 해당하는 `static 블록` 내부에서 초기화가 가능합니다. 객체 상수 역시 선언시에, 또는 객체 생성자에서 초기화할 수 있습니다.
```java
public class Cat{
  final static int constantA = 1;
  final static int constantB;

  static {
    constantB = 1; // 상수는 한 번 초기화되면 값을 변경할 수 없습니다.
  }

  final int constantC = 1;
  final int constantD;

  Cat() {
    constantD = 1; // 상수는 한 번 초기화되면 값을 변경할 수 없습니다.
  }
}
```

다른 언어에서는 읽기 전용인 상수에 대해 const 키워드를 사용하기도 하는데 자바에서는 이런 혼동을 피하기 위해 const를 키워드로 등록해두고, 쓰지 못하게(not used) 하고 있습니다.  
{: .notice--info}


### final과 메서드

메서드가 final이라면 최종이니 재정의, 즉 오버라이딩을 금지하게 됩니다.

```java
public class Cat{
  final void act() {};
}

public class StreetCat extends Cat {
  void act() // 컴파일 에러 발생
}
```

## instanceof 연산자

인스턴스는 클래스를 통해 만들어진 객체입니다. `instanceof` 연산자는 만들어진 객체가 특정 클레스의 인스턴스인지 물어보는 연산자입니다. `instanceof` 연산자의 결과 true또는 false를 반환합니다.

```
객체_참조_변수 instanceof 클래스명 // instanceof 사용 방법
```

instanceof 연산자는 클래스들의 상속 관계뿐만 아니라, 인터페이스의 구현 관계에서도 동일하게 적용됩니다.

instatnceof는 객체 참조 변수의 타입이 아닌 실제 객체의 타입이 클래스의 인스턴스인지 확인합니다.
{: .notice--info}

## package

package 키워드는 `네임스페이스(이름공간)`을 만들어주는 역활을 합니다.

### 네임스페이스의 필요성

만약 회사의 여러 개발조직이 하나의 프로젝트에 참여하고 있다고 가정해보겠습니다. 

고객 사업부 담당 개발팀에서 *Customer*라는 클래스를 작설할 수 있을 겁니다. 그런데 마케팅 사업부 담당 개발팀에서도 *Customer*라는 클래스를 작성한다면 이 두개의 클래스는 `이름 충동`이 발생합니다. 이럴 때 이름 공간을 나누어 각각의 클래스를 *고객사업부.Customer*과 *마케팅사업부.Customer*라고 전체 이름을 지정하면 `이름 충돌`를 피할 수 있습니다.

## interface 키워드와 implements 키워드

인터페이스는 public 추상 메서드와 pulibc 정적 상수만 가질 수 있습니다.
만약 메서드에 `public` `abstract` 키워드, 속성에 `public`, `static` `final` 키워드를 붙이지 않으면 자바 컴파일러가 자동으로 붙여줍니다.

```java
  interface Speakable {
    double PI = 3.14159; // 컴파일러가 public, static, final을 붙여줌
    final double // 컴파일러가 pulbic, static을 붙여줌

    void sayYes(); // 컴팡이러가 public, abstract을 붙여줌
  }
```
